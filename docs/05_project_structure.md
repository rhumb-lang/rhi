## 4\. Project Structure & Storage

Rhumb adopts a unique nomenclature for its file artifacts to distinguish between executable scripts and library code.

### 5\.1 Artifact Terminology

| Term | Concept | Standard Ext | Optional Ext |
| :--- | :--- | :--- | :--- |
| **Letter** | **Script / Executable**. A one-off action. Runs standalone. | `.rh` | `.rhl` |
| **Book** | **Module / Package**. A single file containing library code. Accesses its Shelf directly. | `.rh` | `.rhb` |
| **Shelf** | **Folder**. A directory containing Books. No metadata attached. | N/A | N/A |
| **Library** | **External Package**. A collection of Shelves/Books brought in from outside. | N/A | N/A |
| **Catalog** | **Metadata**. Defines Library properties. | `.rhy` | `.rh.yaml` |

### 5\.2 Shelf Organization

  * **Scope:** A Book can access any other Book within the same Shelf (Folder) implicitly.
  * **Enforcement:** Code structure is managed by the IDE or Compiler Tooling. There are no "package declaration" headers inside the files themselves; the folder structure is the source of truth.

### 5\.3 Libraries & Catalogs

External dependencies are defined via **Catalogs**.

  * **Format:** YAML files with the extension `.rhy` or `.rh.yaml`
  * **Naming Convention:** `LibraryName@SubCatalog.rhy`
      * Example: `networking@http.rhy`
      * **Anonymous Project:** `___@config.rhy` (Project name defined inside the YAML).=
  * **Role:** Catalogs cache the dependency graph and currently in-use libraries per shelf

### 5\.4 The "Babel" Persistence (Twin-File)

For Books managed by the IDE, the source code is decomposed into three file types to support Localization and Git workflows:

1.  **Logic Node (`.__.rh`):** The Canonical AST
      * **Format:** `filename.__.rh`
      * **Content:** Rhumb source using **Raw IDs** (`$x9A2`, `$L01`) instead of human labels
      * **Role:** This is the Source of Truth for the compiler. It ensures referential integrity across renames and languages.
2.  **Translation Map (`.rhy`):** The Label Dictionary (YAML syntax)
      * **Format:** `filename.rhy`
      * **Content:** A YAML map of IDs to localized strings
    <!-- end list -->
    ```yaml
    $x9A:
      en_US: velocity
      fr_FR: vitesse
    $d1B:
      en_US: distance
      fr_FR: distance
    ```
3.  **Localized Artifacts (`.<lang>.rh`):** Read-Only Views
      * **Format:** `filename.en_US.rh`
      * **Content:** Valid Rhumb source generated by the IDE using the Logic Node + Translation Map.
      * **Role:** Allows browsing the code in specific languages (e.g., on GitHub) without needing the Rhumb IDE.

### 5\.5 Dependency Resolution

Dependencies are imported using the **Resolver Protocol**.

  * **Explicit Version:** `{ ! | math | 1.0.0 }`
  * **Latest/Default Version:** `{ ! | math | - }` (Use `-` to indicate no specific version)

| Resolver     | Syntax | Use Case      | Example                            |
|:-------------|:-------|:--------------|:-----------------------------------|
| **Standard** | `!`    | Built-in Libs | `{!\|ðŸ§®\|-}`                     |
| **Local**    | `-`    | Internal Code | `{- \| src\utils\math \| -}`       |
| **Remote**   | `git`  | External Libs | `{git \| https://github... \| dev}` |

**Path Resolution Rules:**
1.  **Implicit (Sibling):** Books within the same Shelf (Folder) can access each
    other directly by label. No import block is required.
2.  **Local Resolver (`-`):** When using the Local Resolver `{-}`, the path is
    **always relative to the Project Root** (The Route / Library Desktop). It is
    *not* relative to the current file. This ensures that moving a file does not
    break its internal imports.

**Version Syntax & Resolution:** The Resolver interprets the **Type** and
**Format** of the literal provided in the version slot. Rhumb uses the `.-`
(DotDash) syntax to explicitly signify wildcards.

**Note on Suffixes:** Version literals may include prerelease (`-alpha`) and
build (`+001`) suffixes. These are treated as **Strict Text Matches** by the
resolver; wildcards cannot be used in conjunction with suffixes.

| Literal        | Syntax      | Type    | Semantics                                                            | Target Match Example |
|:---------------|:------------|:--------|:---------------------------------------------------------------------|:---------------------|
| **`1.2.3`**    | `X.Y.Z`     | Version | **Exact Pin**. Must match exactly.                                   | `/lib@1.2.3`         |
| **`1.2.3-rc`** | `X.Y.Z-Pre` | Version | **Exact Pin with Pre-release**.                                      | `/lib@1.2.3-rc`      |
| **`1.2.-`**    | `X.Y.-`     | Version | **Patch Wildcard**. Highest patch for 1.2.                           | `/lib@1.2.9`         |
| **`1.-`**      | `X.-`       | Number  | **Minor Wildcard**. Highest minor/patch for 1.                       | `/lib@1.9.4`         |
| **`-`**        | `Dash`      | Dash    | **Major Wildcard / Working Copy**. Prefers unversioned Shelves.      | `/lib`               |
| **`1`**        | `X`         | Number  | **Implicit Major**. Same as `1.-` (SemVer `^1.0`).                   | `/lib@1.9.4`         |
| **`stable`**   | `Label`     | Label   | **Variable**. Looks for a matching variable that contains a Version. |                      |


**Float Confusion:** While the ANTLR grammar permits standard Floats (`1.2`) in
version slots, the compiler will issue a warning *"Did you mean to write a
version literal?"* to prevent accidentally typing `1,2.0` which would be
interpreted as version "12". This is because the thousand separators are not
stored so there's no way to differentiate between `12.0` and `1,2.0`. 

**Circular Dependencies:** Rhumb supports circular references between Shelves
for *declarations* (functions/classes) because of the multi-pass Hoister.
However, circular *initialization logic* (top-level code that depends on another
file's top-level code executing first) will trigger a **Runtime Cycle Error**.

## 5\.6 Catalogs

Catalog files must have the same name as the folder but with `@` followed by any additional label (for breaking a catalog into multiple files)

```yaml
# ./my_project@.rhy
# one non-version key is allowed for project/shelf metadata
my_project: 
    ðŸ‘¤: Jake Russo # author
    ðŸªª: MIT # license
    ðŸ“¦: https://github.com/user/repo
    ðŸ·ï¸: # keywords
        - programming 
        - cryptography
        - server
    ðŸ“: >
        This is a description of the project and it can span
        multiple lines using thr yaml ">" operator
    ðŸ“‚: src # if the libraries and desktop books are in non-root folder

# all remaining values in the catalog are versions of the project
-:
    <-: 0.1.0 # this "<-" symbol as a key means that this version has the same dependencies as the value
0.1.0:
    core_mechanics: <- # this "<-" symbol as a value means that core_mechanics shelf contains its own catalog
    win_conditions: <-
    physics: # objects with version keys means that the shelf's catalog is included here
        0.1.0:
            core_mechanics: 0.3.2 # this means that physics@0.1.0 depends on core_mechanics@0.3.2
            math: 0.1.0! # the ! means standard library (all standard libraries are versioned)
    art_files: true # true means this is a asset/resource folder that should be included in any distribution
    integration_checks: false # false means that this is a non-resource folder that should be excluded from any distribution
---
# ./core_mechanics/core_mechanics@.rhy
-: null # since none of the versions contain dependencies, no pointer is needed
0.4.1: null
0.3.2: null # null means that this is a rhumb folder but there's no dependencies and no inner shelves
---
# ./win_conditions/win_conditions@.rhy
-: # we're using the new core_mechanics version in this top shelf
    core_mechanics: 0.4.1
    physics: 0.1.0
0.2.1:
    core_mechanics: 0.3.2
    physics: 0.1.0
0.2.0:
    core_mechanics: 0.3.2
    physics: 0.1.0
---
# ./integration_checks/integration_checks@.rhy
# even though this shelf isn't part of the main library/route, it can still have a catalog
-:
  <-: 0.5.0
0.5.0:
  <-: 0.4.0 # if you are adding only, you can keep the pointer
  win_conditions: 0.2.1
0.4.0:
  core_mechanics: 0.4.1
  physics: 0.1.0
0.3.0:
  core_mechanics: 0.3.2
  physics: 0.1.0
0.2.0:
  <-: 0.1.0
0.1.0:
  physics: 0.1.0
```

```console
$ tree . # inside of a Rhumb project
/project_name
  â”œâ”€â”€ project_name@.rhy
  â””â”€â”€ /src
       â”œâ”€â”€ +main.rh
       â”œâ”€â”€ /core_mechanics
       â”‚     â”œâ”€â”€ /-
       â”‚     â”‚    â”œâ”€â”€ player.rh
       â”‚     â”‚    â””â”€â”€ movement.rh
       â”‚     â”œâ”€â”€ /0.3.2
       â”‚     â”‚    â”œâ”€â”€ player.rh
       â”‚     â”‚    â””â”€â”€ movement.rh
       â”‚     â””â”€â”€ core_mechanics@.rhy
       â”œâ”€â”€ /physics
       â”‚     â”œâ”€â”€ /-
       â”‚     â”‚    â”œâ”€â”€ particle.rh
       â”‚     â”‚    â””â”€â”€ ball.rh
       â”‚     â””â”€â”€ /0.1.0
       â”‚          â”œâ”€â”€ particle.rh
       â”‚          â””â”€â”€ ball.rh
       â”œâ”€â”€ /art_files
       â”‚     â”œâ”€â”€ hero.png
       â”‚     â””â”€â”€ map.json
       â””â”€â”€ /integration_checks
            â””â”€â”€ +integration_checks.rh
```

Since Rhumb is managed by an IDE, the **Working Copy** is decoupled from the
**Archived Versions**.

Instead of editing files directly inside of the numbered version folder (which
changes name), you perform all work in the **"top shelf" (`-`)** (which never changes name). When you "bump" a version,
the IDE snapshots that folder into a numbered archive.

## 5\.7 The Entry Point (`+`)

The entry point of any Shelf (local library) is strictly defined by the file
naming convention.

  * **Syntax:** `+filename.rh`
  * **Constraint:** A Shelf version may contain **only one** file with the `+` prefix.
  * **Behavior:**
      * **Run:** When `rhi ./shelf` is called, the interpreter locates the `+`
        file and begins execution there.
      * **Import:** When a module is imported by another, the `+` file is
        treated just like any other source file in the bundle (its code is
        loaded), but it acts as the "Leader" of the loading order.
  * **Library Mode:** A Shelf with no `+` file is a **Library**. It cannot be
    executed directly.

**Example:**

```text
/my_game
  â”œâ”€â”€ +foo.rh       <-- The "Main" script.
  â”œâ”€â”€ logic.rh
  â””â”€â”€ _helpers.rh    <-- A standard source file.
```

## 5\.8 Shelf Scope (Internal Visibility)

Rhumb uses a **"Flattened Directory Scope."**

  * **The Rule:** All files within a single Shelf version (e.g., inside `/0.1.0/`) share the same scope.
  * **Mechanism:** You do not need to import sibling files. If `logic.rh` defines `CalculateScore`, `+foo.rh` can call it instantly.
  * **Privacy Exception:** This shared scope includes **Private** (`_`) members. Privacy is only enforced across Shelf boundaries, not within the Shelf itself.

-----

## 5\.9 External Visibility (Exports)

Visibility is controlled entirely by the **Label Naming Convention**.

### 5\.9\.1 Public by Default

Any top-level label (function, variable, constant, key) that **does not** start with an underscore is automatically exported.

  * **Definition:** `calculate := [] -> ( ... )`
  * **Access:** Visible to any library or route that imports this Shelf.

### 5\.9\.2 Private by Prefix (`_`)

Any top-level label starting with an underscore `_` is strictly internal.

  * **Definition:** `_validate .= [] -> ( ... )`
  * **Access:**
      * Visible to sibling files (e.g., `logic.rh` can call `_validate` defined in `helpers.rh`).
      * **Invisible** to importers (e.g., if `Game` imports `Physics`, it cannot see `Physics\_validate`).

### 5\.9\.3 Visual Example

**File: `/physics/collision.rh`**

```rhumb
% Public: The world can see this
check-overlap .= [a;, b] (
    _boxes_touch(a; b) => (
        ...
    )
)

% Private: Only the 'physics' shelf can see this
_boxes_touch .= [a; b] -. (
    ...
)
```

**File: `/game/+main.rh`**

```rhumb
phys := {-|physics|1.-}

% Valid
phys\CheckOverlap(p1; p2)

% Error: '_boxes_touch' is not defined in library 'physics'
phys\_boxes_touch(p1, p2)
```

