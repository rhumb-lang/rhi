## 4\. Project Structure & Storage

Rhumb adopts a unique nomenclature for its file artifacts to distinguish between executable scripts and library code.

### 5\.1 Artifact Terminology

| Term | Concept | Standard Ext | Optional Ext |
| :--- | :--- | :--- | :--- |
| **Letter** | **Script / Executable**. A one-off action. Runs standalone. | `.rh` | `.rhl` |
| **Book** | **Module / Package**. A single file containing library code. Accesses its Shelf directly. | `.rh` | `.rhb` |
| **Shelf** | **Folder**. A directory containing Books. No metadata attached. | N/A | N/A |
| **Library** | **External Package**. A collection of Shelves/Books brought in from outside. | N/A | N/A |
| **Catalog** | **Metadata**. Defines Library properties. | `.rhy` | `.rh.yaml` |

### 5\.2 Shelf Organization

  * **Scope:** A Book can access any other Book within the same Shelf (Folder) implicitly.
  * **Enforcement:** Code structure is managed by the IDE or Compiler Tooling. There are no "package declaration" headers inside the files themselves; the folder structure is the source of truth.

### 5\.3 Libraries & Catalogs

External dependencies are defined via **Catalogs**.

  * **Format:** YAML files with the extension `.rhy` or `.rh.yaml`
  * **Naming Convention:** `LibraryName@SubCatalog.rhy`
      * Example: `networking@http.rhy`
      * **Anonymous Project:** `___@config.rhy` (Project name defined inside the YAML).=
  * **Role:** Catalogs cache the dependency graph and currently in-use libraries per shelf

### 5\.4 The "Babel" Persistence (Twin-File)

For Books managed by the IDE, the source code is decomposed into three file types to support Localization and Git workflows:

1.  **Logic Node (`.__.rh`):** The Canonical AST
      * **Format:** `filename.__.rh`
      * **Content:** Rhumb source using **Raw IDs** (`$x9A2`, `$L01`) instead of human labels
      * **Role:** This is the Source of Truth for the compiler. It ensures referential integrity across renames and languages.
2.  **Translation Map (`.rhy`):** The Label Dictionary (YAML syntax)
      * **Format:** `filename.rhy`
      * **Content:** A YAML map of IDs to localized strings
    <!-- end list -->
    ```yaml
    $x9A:
      en_US: velocity
      fr_FR: vitesse
    $d1B:
      en_US: distance
      fr_FR: distance
    ```
3.  **Localized Artifacts (`.<lang>.rh`):** Read-Only Views
      * **Format:** `filename.en_US.rh`
      * **Content:** Valid Rhumb source generated by the IDE using the Logic Node + Translation Map.
      * **Role:** Allows browsing the code in specific languages (e.g., on GitHub) without needing the Rhumb IDE.

### 5\.5 Dependency Resolution

Dependencies are imported using the **Resolver Protocol**.

  * **Explicit Version:** `{ ! | math | 1.0.0 }`
  * **Latest/Default Version:** `{ ! | math | - }` (Use `-` to indicate no specific version)

| Resolver     | Syntax | Use Case      | Example                             |
|:-------------|:-------|:--------------|:------------------------------------|
| **Standard** | `!`    | Built-in Libs | `{!\|ðŸ§®\|-}`                        |
| **Local**    | `-`    | Internal Code | `{-\|src\utils\math \|-}`        |
| **Resource** | `=`    | Static Assets | `{=\|assets/icons/logo.png \|-}`  |
| **Remote**   | `git`  | External Libs | `{git\|https://github...\|0.1.0}` |

**Path Resolution Rules:**
1.  **Implicit (Sibling):** Books within the same Shelf (Folder) can access each
    other directly by label. No import block is required.
2.  **Local Resolver (`-`):** The Local Resolver `{-}` performs a **Two-Step Lookup**:
  * **Step A (Logical Alias):** It first checks the active `catalog.rhy` for a dependency key matching the provided label (e.g., `math`). If found, it resolves to the version or path defined in the catalog.
  * **Step B (Physical Path):** If no alias is found, it treats the string as a **File System Path** relative to the **Project Root** (e.g., `src/libs/math`).

**Version Syntax & Resolution:** The Resolver interprets the **Type** and
**Format** of the literal provided in the version slot. Rhumb uses the `.-`
(DotDash) syntax to explicitly signify wildcards.

**Note on Suffixes:** Version literals may include prerelease (`-alpha`) and
build (`+001`) suffixes. These are treated as **Strict Text Matches** by the
resolver; wildcards cannot be used in conjunction with suffixes.

| Literal        | Syntax      | Type    | Semantics                                                            | Target Match Example |
|:---------------|:------------|:--------|:---------------------------------------------------------------------|:---------------------|
| **`1.2.3`**    | `X.Y.Z`     | Version | **Exact Pin**. Must match exactly.                                   | `/lib@1.2.3`         |
| **`1.2.3-rc`** | `X.Y.Z-Pre` | Version | **Exact Pin with Pre-release**.                                      | `/lib@1.2.3-rc`      |
| **`1.2.-`**    | `X.Y.-`     | Version | **Patch Wildcard**. Highest patch for 1.2.                           | `/lib@1.2.9`         |
| **`1.-`**      | `X.-`       | Number  | **Minor Wildcard**. Highest minor/patch for 1.                       | `/lib@1.9.4`         |
| **`-`**        | `Dash`      | Dash    | **Major Wildcard / Working Copy**. Prefers unversioned Shelves.      | `/lib`               |
| **`1`**        | `X`         | Number  | **Implicit Major**. Same as `1.-` (SemVer `^1.0`).                   | `/lib@1.9.4`         |
| **`stable`**   | `Label`     | Label   | **Variable**. Looks for a matching variable that contains a Version. |                      |


**Float Confusion:** While the ANTLR grammar permits standard Floats (`1.2`) in
version slots, the compiler will issue a warning *"Did you mean to write a
version literal?"* to prevent accidentally typing `1,2.0` which would be
interpreted as version "12". This is because the thousand separators are not
stored so there's no way to differentiate between `12.0` and `1,2.0`. 

**Circular Dependencies:** Rhumb supports circular references between Shelves
for *declarations* (functions/classes) because of the multi-pass Hoister.
However, circular *initialization logic* (top-level code that depends on another
file's top-level code executing first) will trigger a **Runtime Cycle Error**.

## 5\.6 Catalogs

Catalog files must have the same name as the folder but with `@` followed by any
additional label (for breaking a catalog into multiple files). Dependencies are
defined in the version map. Rhumb differentiates between **Code Dependencies**
(Strings) and **Resource Dependencies** (Arrays).

```yaml
# ./my_project@.rhy
# one non-version key is allowed for project/shelf metadata
my_project: 
    ðŸ‘¤: Jake Russo # author
    ðŸªª: MIT # license
    ðŸ“¦: https://github.com/user/repo
    ðŸ·ï¸: # keywords
        - programming 
        - cryptography
        - server
    ðŸ“: >
        This is a description of the project and it can span
        multiple lines using thr yaml ">" operator
    ðŸ“‚: src # if the libraries and desktop books are in non-root folder

# all remaining values in the catalog are versions of the project
-:
    <-: 0.1.0 # this "<-" symbol as a key means that this version has the same dependencies as the value
0.1.0:
    core_mechanics: <- # this "<-" symbol as a value means that core_mechanics shelf contains its own catalog
    win_conditions: <-
    physics: # objects with version keys means that the shelf's catalog is included here
        0.1.0:
            core_mechanics: 0.3.2 # this means that physics@0.1.0 depends on core_mechanics@0.3.2
            math: 0.1.0! # the ! means standard library (all standard libraries are versioned)

    # The brackets indicate this is a Resource Shelf.
    art_files: [0.1.0] # Maps to: /src/[art_files]/0.1.0
    
    # if you are using the flag for allowing wildcards, you could reference the tip version directly
    sounds: [-] # Maps to: /src/[sounds]/-
    # if you want to specify a resource catalog inline, use the - dash leading line to indicate []
    icons: # Maps to: /src/[icons] (just a folder of files)
    - logo.png: sha256:a1b2...
    - spinner.gif: ___ # the triple underscore ____ means that the user has not yet added a checksum

    # false means that this is a non-resource folder that should be excluded from any distribution
    integration_checks: false # but it could still have its own catalog (like for testing routes)
---
# ./core_mechanics/core_mechanics@.rhy
-: null # since none of the versions contain dependencies, no pointer is needed
0.4.1: ~ # in YAML ~ is equivalent to null
0.3.2: null # null means that this is a rhumb folder but there's no dependencies and no inner shelves
---
# ./win_conditions/win_conditions@.rhy
-: # we're using the new core_mechanics version in this top shelf
    core_mechanics: 0.4.1
    physics: 0.1.0
0.2.1:
    core_mechanics: 0.3.2
    physics: 0.1.0
0.2.0:
    core_mechanics: 0.3.2
    physics: 0.1.0
---
# ./integration_checks/integration_checks@.rhy
# even though this shelf isn't part of the main library/route, it can still have a catalog
-:
  <-: 0.5.0
0.5.0:
  <-: 0.4.0 # if you are adding only, you can keep the pointer
  win_conditions: 0.2.1
0.4.0:
  core_mechanics: 0.4.1
  physics: 0.1.0
0.3.0:
  core_mechanics: 0.3.2
  physics: 0.1.0
0.2.0:
  <-: 0.1.0
0.1.0:
  physics: 0.1.0
```

### 5\.6\.1 Catalog Metadata (User-Defined in `.rhy`)

This is what exists in the `project@.rhy` file.

| Emoji Key | Name | Type | Description |
| :--- | :--- | :--- | :--- |
| **`ðŸ‘¤`** | **Author** | String | The maintainer or organization. |
| **`ðŸªª`** | **License** | String | SPDX license identifier. |
| **`ðŸ“¦`** | **Repo** | URL | Source code repository. |
| **`ðŸ·ï¸`** | **Tags** | List | Keywords for indexing/search. |
| **`ðŸ“`** | **Desc** | String | Multi-line description. |
| **`ðŸ“‚`** | **Root** | Path | **Source Root.** If set (e.g. `src`), all shelf lookups happen relative to this folder. |


### 5\.6\.2 Example Library/Route Folder

Since Rhumb is managed by an IDE, the **Working Copy** is decoupled from the
**Archived Versions**.

Instead of editing files directly inside of the numbered version folder (which
changes name), you perform all work in the **"top shelf" (`-`)** (which never changes name). When you "bump" a version,
the IDE snapshots that folder into a numbered archive. These folders sit alongside
the shelves or other resource folders of the project.

```console
$ tree . # inside of a Rhumb project
/project_name
  â”œâ”€â”€ project_name@.rhy
  â””â”€â”€ /src
       â”œâ”€â”€ /-                 <-- Root Project Tip
       â”‚    â””â”€â”€ +main.rh
       â”œâ”€â”€ /0.1.0             <-- Root Project Version
       â”‚    â””â”€â”€ +main.rh
       â”œâ”€â”€ /core_mechanics
       â”‚    â”œâ”€â”€ /-
       â”‚    â”‚    â”œâ”€â”€ player.rh
       â”‚    â”‚    â””â”€â”€ movement.rh
       â”‚    â”œâ”€â”€ /0.3.2
       â”‚    â”‚    â”œâ”€â”€ player.rh
       â”‚    â”‚    â””â”€â”€ movement.rh
       â”‚    â””â”€â”€ core_mechanics@.rhy
       â”œâ”€â”€ /physics
       â”‚    â”œâ”€â”€ /-
       â”‚    â”‚    â”œâ”€â”€ particle.rh
       â”‚    â”‚    â””â”€â”€ ball.rh
       â”‚    â””â”€â”€ /0.1.0
       â”‚         â”œâ”€â”€ particle.rh
       â”‚         â””â”€â”€ ball.rh
       â”œâ”€â”€ /art_files
       â”‚    â”œâ”€â”€ /-
       â”‚    â”‚    â”œâ”€â”€ hero.png
       â”‚    â”‚    â”œâ”€â”€ map.json
       â”‚    â”‚    â””â”€â”€ enemy.png
       â”‚    â”œâ”€â”€ /0.2.0
       â”‚    â”‚    â”œâ”€â”€ hero.png
       â”‚    â”‚    â””â”€â”€ map.json
       â”‚    â””â”€â”€ /0.1.0
       â”‚         â”œâ”€â”€ hero.png
       â”‚         â””â”€â”€ map.json
       â””â”€â”€ /integration_checks
            â”œâ”€â”€ /-
            â”‚    â””â”€â”€ +integration_checks.rh
            â”œâ”€â”€ /0.5.0
            â”‚    â””â”€â”€ +integration_checks.rh
            â”œâ”€â”€ /0.4.0
            â”‚    â””â”€â”€ +integration_checks.rh
            â”œâ”€â”€ /0.3.0
            â”‚    â””â”€â”€ +integration_checks.rh
            â”œâ”€â”€ /0.2.0
            â”‚    â””â”€â”€ +integration_checks.rh
            â””â”€â”€ /0.1.0
                 â””â”€â”€ +integration_checks.rh
```

### 5\.6\.3 Runtime Metadata (Resolver-Generated)

This is what the `LibraryLoader` generates and stores in memory (or the `.ri` snapshot) after scanning the disk.

| Field                 | Type   | Source      | Purpose                                                                                                    |
|:----------------------|:-------|:------------|:-----------------------------------------------------------------------------------------------------------|
| **`ResolvedVersion`** | String | Calculated  | The concrete SemVer (e.g., `1.2.3`).                                                                       |
| **`PhysicalPath`**    | Path   | Calculated  | Absolute path to the shelf directory (e.g., `/abs/project/src/physics/0.1.0`).                             |
| **`EntryPoint`**      | Path   | **Scanned** | The absolute path to the `+filename.rh` file found in that directory. `null` if it's a library-only shelf. |
| **`Dependencies`**    | List   | Catalog    | Pre-calculated list of dependencies for this specific version.                                             |
| **`Integrity`**       | Hash   | Calculated  | SHA-256 of the shelf contents (for security/caching).                                                      |

### 5\.6\.4 Dependency Aliasing**

The keys in the `Dependencies` block act as **Logical Aliases**. This allows you
to rename libraries or move them without changing your source code imports.

 **Catalog Example:**

 ```yaml
 # project@.rhy
 0.1.0:
   # logical_name : specific_version_or_path
   physics_engine: libs/physics
   standard_math: ðŸ§®@1.0.0! # we use the original name followed by @ for an alias
 ```

**Source Exmaple:**

 ```rhumb
% main.rh
% Import using the alias, not the path
phys := {-|physics_engine|-}
math := {-|standard_math|-}
 ```


## 5\.7 The Entry Point (`+`)

The entry point of any Shelf (local library) is strictly defined by the file
naming convention.

  * **Syntax:** `+filename.rh`
  * **Constraint:** A Shelf version may contain **only one** file with the `+` prefix.
  * **Behavior:**
      * **Run:** When `rhi ./shelf` is called, the interpreter locates the `+`
        file and begins execution there.
      * **Import:** When a module is imported by another, the `+` file is
        treated just like any other source file in the bundle (its code is
        loaded), but it acts as the "Leader" of the loading order.
  * **Library Mode:** A Shelf with no `+` file is a **Library**. It cannot be
    executed directly.

**Example:**

```text
/my_game
  â”œâ”€â”€ +foo.rh       <-- The "Main" script.
  â”œâ”€â”€ logic.rh
  â””â”€â”€ _helpers.rh    <-- A standard source file.
```

## 5\.8 Shelf Scope (Internal Visibility)

Rhumb uses a **"Flattened Directory Scope."**

  * **The Rule:** All files within a single Shelf version (e.g., inside `/0.1.0/`) share the same scope.
  * **Mechanism:** You do not need to import sibling files. If `logic.rh` defines `CalculateScore`, `+foo.rh` can call it instantly.
  * **Privacy Exception:** This shared scope includes **Private** (`_`) members. Privacy is only enforced across Shelf boundaries, not within the Shelf itself.

-----

## 5\.9 External Visibility (Exports)

Visibility is controlled entirely by the **Label Naming Convention**.

### 5\.9\.1 Public by Default

Any top-level label (function, variable, constant, key) that **does not** start with an underscore is automatically exported.

  * **Definition:** `calculate := [] -> ( ... )`
  * **Access:** Visible to any library or route that imports this Shelf.

### 5\.9\.2 Private by Prefix (`_`)

Any top-level label starting with an underscore `_` is strictly internal.

  * **Definition:** `_validate .= [] -> ( ... )`
  * **Access:**
      * Visible to sibling files (e.g., `logic.rh` can call `_validate` defined in `helpers.rh`).
      * **Invisible** to importers (e.g., if `Game` imports `Physics`, it cannot see `Physics\_validate`).

### 5\.9\.3 Visual Example

**File: `/physics/collision.rh`**

```rhumb
% Public: The world can see this
check-overlap .= [a;, b] (
    _boxes_touch(a; b) => (
        ...
    )
)

% Private: Only the 'physics' shelf can see this
_boxes_touch .= [a; b] -. (
    ...
)
```

**File: `/game/+main.rh`**

```rhumb
phys := {-|physics|1.-}

% Valid
phys\CheckOverlap(p1; p2)

% Error: '_boxes_touch' is not defined in library 'physics'
phys\_boxes_touch(p1, p2)
```

## 5\.10 Resource Resolution

Static assets (images, JSON configuration, database files) are imported using the **Resource Resolver `{=}`**. Unlike code imports which load a "Shelf," resource imports load a specific **File**.

**Syntax:** `{ = | path/to/shelf/filename.ext | version }`

### 5\.10\.1 The Bracketed Protocol

Resource Shelves are strictly typed in the catalog using YAML Arrays.

1.  **Catalog Definition:** `name: ["version"]`
2.  **Disk Location:** The loader automatically looks for a folder named `[name]`.
3.  **Versioning:**
    * **Versioned:** `["1.0.0"]` â†’ `src/[name]/1.0.0/`
    * **Tip:** `[-]` â†’ `src/[name]/-/`
    * **Inline:** `[{...}]` â†’ `src/[name]/` (The version is implicitly "local").

**Example `shelf@.rhy`:**
```yaml
-:
  <-: 0.1.0 # uses dependency graph for 0.1.0
  # if any files change from 0.1.0, the pointer can no longer be used
  # if only new files are added, the pointer can still be used alongside the new key-value resource pairs
0.1.0:
  # --- Auto-Discovery ---
  # Inferred from extension (.json -> Map, .png -> Binary)
  config.json: sha256:a1b2c3...
  hero.png: ___ # system will add checksum on next run

  # --- Explicit Options (Key Suffix) ---
  # Force specific encoding or MIME type via semicolon
  legacy.data;iso-8859-1: sha256:e3b0c44...
  raw_config.json;text/plain: sha256:c1c149af...  # Load as Text, do not parse

  # --- Integrity & Security ---
  # Checksums are required, the loader validates the bytes before returning.
  secure.db: sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
```

**Constraint:** Resource filenames defined in the catalog must not contain
semi-colons (;). If a file on disk has one, it must be renamed to be compatible
with the Symbolic Protocol.

**Generation:** Setting the value to `___` acts as a request for the **IDE or
Build Tool** to calculate the SHA-256 hash and update the catalog file. The
Runtime (VM) will throw an error if it encounters `___` in a production/frozen
environment, enforcing integrity.

### 5\.10\.2 Runtime Behavior Matrix

The Loader determines the return type based on the MIME type, which is either
inferred from the file extension or explicitly overridden in the catalog.

| File Extension            | Default MIME               | Runtime Value | Description                             |
|:--------------------------|:---------------------------|:--------------|:----------------------------------------|
| **`.json`**               | `application/json`         | **Map**       | Automatically parsed into a Rhumb Map.  |
| **`.txt`, `.rtf`, `.md`** | `text/plain`               | **Text**      | Loaded as a UTF-8 string.               |
| **`.png`, `.jpg`, etc.**  | `image/*`                  | **Slip**      | Returns a lightweight slip (see below). |
| **`.db`, `.sqlite`**      | `application/x-sqlite3`    | **Slip**      | Returns a slip for DB drivers.          |
| **(Unknown)**             | `application/octet-stream` | **Slip**      | Raw binary slip.                        |

### 5\.10\.3 Options & Overrides

You can modify the loading behavior by appending options to the filename in the
catalog key.

  * **`utf-8` / `iso-8859-1`**: Forces text decoding using the specified charset.
  * **`base64`**: Loads binary data but returns it as a Base64-encoded **Text** string.
  * **`text/plain`**: Forces treating a file (like `.json`) as raw text instead of parsing it.
  * **`application/json`**: Forces parsing a file (like `.config`) as JSON.

### 5\.10\.4 Slips (Resource Handles)

For binary assets (images, audio) or large files (databases), loading the entire
content into the VM stack is inefficient. In these cases, the Resolver returns a
**Slip** which is a resource handle.

  * **Type:** `Slip`
  * **Fields:**
      * `\path`: The absolute path to the verified file on disk.
      * `\mime`: The resolved MIME type.
  * **Usage:** Standard Library functions accept slips directly.
    ```rhumb
    db_res := {=|database/users.db|0.1.0}  % Returns Slip
    conn := sql\open(db_res)      % Opens the path defined in the slip
    ```
<!-- end list -->

**Semantics:** A Slip represents **Verified Permission** to access a specific
asset. It does not load the asset into memory.

**Streaming:** Standard library functions (like `io\open(slip)`) use the Slip to
open a file descriptor, allowing for random access and streaming of large assets
(video/databases) without memory pressure.

**Security:** Slips are **Opaque Handles**. They cannot be constructed manually
via Map literals. This ensures that all Slips passed to standard library
functions have originated from the verified Resolver logic and point to
sandboxed, checksummed assets.


